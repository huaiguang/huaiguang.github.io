{"meta":{"title":"怀光的博客","subtitle":"记录生活的点点滴滴","description":"Where there is a will, there is a way!","author":"Artemis","url":"http://yoursite.com","root":"/"},"pages":[{"title":"自我介绍","date":"2021-04-28T17:47:34.000Z","updated":"2021-04-28T17:47:34.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-05-13T16:01:11.000Z","updated":"2021-05-13T16:01:11.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Gallery","date":"2021-04-28T17:47:01.000Z","updated":"2021-04-28T17:47:01.000Z","comments":true,"path":"gallery/index.html","permalink":"http://yoursite.com/gallery/index.html","excerpt":"","text":"前言收集到的一些角色图 miku"},{"title":"tags","date":"2021-05-13T16:01:28.000Z","updated":"2021-05-13T16:01:28.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"hexo-theme","slug":"hexo-theme-next","date":"2019-12-29T18:00:00.000Z","updated":"2019-12-29T18:00:00.000Z","comments":true,"path":"2019/12/29/hexo-theme-next/","link":"","permalink":"http://yoursite.com/2019/12/29/hexo-theme-next/","excerpt":"","text":"利用Hexo搭建博客采用Hexo系统，利用markdown语法来编写博客，适合初步搭建博客的开发人员。从github上下载hexo并安装，有自带的主题landscape，就可以搭建起一个简易博客系统。如果期望做的更多一点，博客网站更好一些，那么可以试试替换下主题，也可以接着看下去。本篇主要讲述下主题：Next的配置。 约定在讲述配置时，可能会遇到不同位置的相同文件名的文件(其实主要是 _config.yml). 故约定如下： 单独的 _config.yml 指根目录下的 _config.yml, 可以配置使用哪种主题 themes/_config.yml 指主题下的 _config.yml, 是theme主题的配置 主题配置一般的主题基本上按照 theme/_config.yml 下的注释就可以看懂，以及相关的配置，下面讲述下遇到的问题。 易忽略点Question1: 在Schemes配置中，选择主题 scheme: Gemini 时, 左侧边栏中 categories tags 上面没有链接，不可点击回答：默认情况下，posts 标签点开时，网站跳转到 /archives/. 同理, 点击标签 categories, tags时，网站跳转的地址分别是 /categories/, /tags/. 默认情况下，系统中不存在相应的页面，需要按照如下操作处理. 在 themes/_config.yml 的 menu 下，放开 categories, tags的注释 按照如下操作，添加 categories, tags 文件夹, 并手动修改其中的index.md1234567# 在source下建立 categories 文件夹, 并创建了一个 index.mdnode_modules/.bin/hexo new page categories# 修改 categories/index.md, 在生成的 description 后面手动添加 type: &quot;categories&quot;# 在source下建立 tags 文件夹, 并创建了一个 index.mdnode_modules/.bin/hexo new page tags# 修改 tags/index.md, 在生成的 description 后面手动添加 type: &quot;tags&quot; 重新启动, npm run clean &amp;&amp; npm run build &amp;&amp; npm run server，左侧边栏中的categories, tags上即附上了链接 发布 本篇主要讲述在Github上的发布. 在Github上发布有两种思路，一是通过hexo自带的deploy发布，二是通过发布到xxx.github.io设定自动任务发布。第一种方式比较实用，主要有以下几步。 首先在根目录下安装插件 npm install hexo-deployer-git --save. 在 _config.yml上配置deployment,示例如下：12345678910# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: - type: git repository: git@github.com:xxx/xxx.github.io.git branch: master - type: git repo: https://gitee.com/lxl80/lxl80.git branch: master ignore_hidden: false 本质上就是在本地通过cli命令 hexo clean &amp;&amp; hexo build &amp;&amp; hexo deploy, 在本地打包，将生成的public文件夹上传到github上。Github Pages 相当于一个静态资源服务器，上传完成后即可通过 https://xxx.github.io/ 来进行访问. 优势是容易迁移，支持一键发布到多个平台，几乎不存在劣势。 第二种方式是采用 travis, 在本地完成了编辑后推送到远程触发travis，travis执行设定的任务，自动打包并发布到指定分支, 完成后Github Pages就会自动更新。主要有以下的步骤： 进入Github的Settings/Developer settings下，注册一个GH_TOKEN. 使用github账号登录travis, 待同步项目后，进入相应的项目设置页。 在项目配置中找到 Environment Variables 中添加GH_TOKEN. 在本地添加travis的配置文件 .travis.yml, 里面是推送后的自动化任务配置. 示例如下：123456789101112131415161718192021222324sudo: falselanguage: node_jsnode_js: - 12cache: npm# 执行分支branches: only: - master# 推送后执行的命令script: - hexo generate# 发布deploy: provider: pages skip-cleanup: true github-token: $travis_token keep-history: true on: all_branches: true branch: gh-pages local-dir: public 在travis-ci.org中执行完毕后, 刷新 xxx.github.io 即可.与第一种方式相比, 主要是节省了本地资源(虽然大多数并不需要). 时间成本上, 虽然一个在本地一个在线上，但是我们自己都是要等待编辑执行，实际上本地可能更快捷一些。","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo themes","slug":"hexo-themes","permalink":"http://yoursite.com/tags/hexo-themes/"}]},{"title":"JS基础-闭包","slug":"js-closure","date":"2019-12-15T18:00:00.000Z","updated":"2019-12-15T18:00:00.000Z","comments":true,"path":"2019/12/15/js-closure/","link":"","permalink":"http://yoursite.com/2019/12/15/js-closure/","excerpt":"","text":"前言JS基础解析系列, 主要是为了弄清楚JS中一些常见但容易出错，不常见但有助于理解代码的要点。不定时更新，请多多见谅。闭包是JS中很常见的一种写法。本质是利用函数的嵌套，和函数的作用域(内部函数访问外部变量)，来创建出模拟的块级作用域。利用闭包，基本的目的是创造一个封闭的变量，避免污染全局变量，来完成包的封装。 使用示例闭包常见的使用模式如下: 12345678910111213141516171819/** * 防抖函数 * @param &#123;function&#125; fn, 待执行的函数 * @param &#123;number&#125; wait, 延时的时间(单位毫秒) */function debounce(fn, wait = 300) &#123; let timer return function() &#123; const args = arguments const context = this if (timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) &#125;, wait) &#125;&#125; 以上是简版的防抖函数. 不过也将闭包的一些点展示了出来： 内部函数访问外部函数的变量 内部函数this的指向问题 内存泄漏问题 第一个问题，也是闭包必要性的根本。假如不使用闭包，要如何实现上面的功能。简洁一点的实现是直接定义一个或者多个全局变量。但定义了全局变量，更多的问题也随之而来。比较棘手的问题有：全局变量污染，内存占用。这些都可能会导致严重的不可预知的bug。使用闭包，最根本上就是为了规避这种难题。通过模拟一个块级作用域，将变量限定在一个范围内，减少对其它代码的影响。 第二个问题，保证this指向一致性。this的指向也一直是个难题。假如不做处理，this会默认指向当前执行的上下文(context)。以上面的防抖函数为例，为了保持this指向的一致性，就需要一些额外的处理。通过apply传递this, 以及函数的默认参数(arguments), 将当前环境，以及参数传递给需要的执行函数fn，以此来保证this和参数的一致性。在常见的dom操作中，这样就保证了dom和mouseEvent的传递。 第三个问题，内存泄漏由于闭包导致的内存泄漏，实质上是IE9之前的版本对JScript对象和COM对象使用不同的垃圾回收机制。 12345678910// 常见的遍历domfunction foo () &#123; var element = document.getElementById(&#x27;someElement&#x27;) // 只要匿名函数存在，element引用数至少为1 element.onclick = function () &#123; alert(element.id) // 闭包内，一直执行的是外层引用的element，闭包执行完后，element的引用数无法减少，导致无法释放销毁 &#125;&#125; 除此之外，闭包本身不会因此而造成内存泄漏. 总结闭包本身的概念是相对简单的，但也是应用极为广泛的存在. 虽然实际应用中会遇到各种变种，但详细掌握后，基本上就不会存在理解的障碍。 引用 聊聊闭包那些事","categories":[{"name":"JS base","slug":"JS-base","permalink":"http://yoursite.com/categories/JS-base/"}],"tags":[{"name":"js closure","slug":"js-closure","permalink":"http://yoursite.com/tags/js-closure/"}]},{"title":"JS基础-原型","slug":"js-prototype","date":"2019-12-08T18:00:00.000Z","updated":"2019-12-08T18:00:00.000Z","comments":true,"path":"2019/12/08/js-prototype/","link":"","permalink":"http://yoursite.com/2019/12/08/js-prototype/","excerpt":"","text":"前言JS基础解析系列, 主要是为了弄清楚JS中一些常见但容易出错，不常见但有助于理解代码的要点。不定时更新，请多多见谅。 原型是JS中很重要的一个概念，JS中面向对象编程的基础。所有的对象都有其原型, 所有对象上__proto__属性链接起来的原型链，是JS这门语言的构成的基础。理解好原型，在阅读源码，编写组件等诸多方面，有相当的益处。 原型(prototype)JS 中每个函数都有一个prototype原型对象, 例如Object.prototype. 比较常见的代码如下: 1234567891011121314function Point(x, y) &#123; this.x = x this.y = y&#125;Point.prototype.say = function() &#123; return `x is $&#123;this.x&#125;, y is $&#123;this.y&#125;`&#125;const pointA = new Point(1,2)console.log(pointA) // Point &#123; x: 1, y: 2 &#125;const sayA = pointA.say()console.log(&#x27;say:&#x27;, sayA) // say: x is 1, y is 2 如果仔细一点的话，可以在以上的代码中发现一些特别的地方： 定义的Point函数首字母大写 在console中打印的Point对象中，除去定义的属性x, y, 还有一个__proto__属性. 在__proto__属性中, 有上面显示定义的say函数, 还有constructor(指向Point函数), 以及__proto__(指向Object.prototype). 构造函数(constructor)类似于上面定义的 Point函数, 这类函数叫做构造函数。比较常见的构造函数为Object, Array, String等等。通过new关键字, 构造函数可以创建一个对象。 new关键字创建对象的过程如下: 创建一个继承于构造函数的prototype属性的对象 调用构造函数, 并将步骤1新创建的对象作为this的上下文 如果构造函数的是一个对象, 则返回这个对象；否则返回的是上述步骤中新创建的this. 返回了对象，覆盖了定义的对象类型的情况暂不讨论。这里集中于没有返回对象，按照定义的对象类型创建了对象示例的情况. 经构造函数创建的所有实例，共享构造函数的prototype，这也是js继承的基础。 prototype和__proto__属性*每一个方法都有原型prototype，每一个对象都有一个__proto__.* 每个对象的__proto__属性指向其构造函数的 prototype 属性。构造函数本身作为对象，其__proto__属性指向Function.prototype来做一些有趣的实验, 如下的表达式是true or false. 12345678pointA.__proto__ === Point.prototypepointA.__proto__.constructor === PointPoint.__proto__ === Function.prototypePoint.prototype.__proto__ === Object.prototypePoint.prototype.constructor === PointFunction.prototype.__proto__ === Object.prototypeObject.prototype.__proto__ === null 稍微花费点时间考虑下，或许收获会更多。 原型链(__proto__)所有创建的实例，都可以通过__proto__属性连接其构造函数的prototype. 例如上文中pointA.x和pointA.say都可以访问, pointA.x是显式访问，pointA.say则是隐式访问.隐式访问是通过原型链来实现的。实例对象与原型之间的连接，叫做原型链。当在对象中查找某个属性时，如果在当前的对象中能够查到，该直接返回该属性；如果在当前的对象中查找不到，则会顺着原型链，即__proto__属性指向的对象往上查找，直到到达链路的源头。 继承12345678910111213141516function Point(x, y) &#123; this.x = x this.y = y&#125;Point.prototype.say = function() &#123; return `x is $&#123;this.x&#125;, y is $&#123;this.y&#125;`&#125;const pointA = new Point(1,2)const pointB = new Point(3,4)// JS中两个对象不会全等, 只有相同的对象引用才会全等pointA.x === 1 // truepointB.x === 3 // truepointA.say === pointB.say // true 落实到代码中, 也就是创建类似class的继承。通过构造函数创建的对象，定义的属性是各自的，但__proto__指向的constructor的prototype是共享的。在ES2015中，可以直接通过关键戏class来创建对象了，不过polyfill的实现也是基于此。上述是基本的继承，在实际应用中，会为了满足需求，做一些封装，不过那是另一个篇章了。 引用 MDN","categories":[{"name":"JS base","slug":"JS-base","permalink":"http://yoursite.com/categories/JS-base/"}],"tags":[{"name":"js prototype","slug":"js-prototype","permalink":"http://yoursite.com/tags/js-prototype/"}]},{"title":"JS基础-this","slug":"js-this","date":"2019-12-01T18:00:00.000Z","updated":"2019-12-01T18:00:00.000Z","comments":true,"path":"2019/12/01/js-this/","link":"","permalink":"http://yoursite.com/2019/12/01/js-this/","excerpt":"","text":"前言JS基础解析系列, 主要是为了弄清楚JS中一些常见但容易出错，不常见但有助于理解代码的要点。不定时更新，请多多见谅。 thisthis是JS中绕不过的要点，方方面面都和其相关。在技术的变迁中，this的疑问也有各种各种的变化。下面就将按照不同的背景，讲述下this的指向问题。 在ES2015之前在ES6之前, 最常用的包还是jQuery的时代. 主流的方式是通过构造函数，模拟面向对象来编写代码.常见用法如下: 123456789101112131415161718192021// 不指定// 严格模式下, this指向undefined,// &#x27;use strict&#x27;// 非严格模式下, this指向全局变量windowfunction show() &#123; this.a = &#x27;Hello world!&#x27;&#125;show()// 直接在元素上添加方法document.getElementById(&#x27;test&#x27;).onclick = function() &#123; // this指向id为test的元素 this.innerHTML = &#x27;Hello world!&#x27;&#125;// 构造函数+newfunction Point() &#123; // this指向当前创建的对象 this.x = x this.y = y&#125; 在ES2015之后ES6中引入了箭头函数(=&gt;), 增加了一种this的使用方法. 配合上Vue, React等框架，降低了前端开发的难度，使得前端可以更加的专注于业务.常见的用法如下: 12345// 箭头函数// 常见的Vue中reload方法this.$nextTick(() =&gt; &#123; this.reload()&#125;) 特殊调用在JS中, 为了提高代码的效率, 提供了几个可以改变this指向的函数call, apply和bind. 虽然和本文介绍this指向的关系不大, 但稍微提及下.常见的调用方式如下: 123456789// call &amp; apply// attention: call的参数从第二个起是单独的参数，apply的第二个参数是数组// 将node节点列表的类数组转化为真正的数组Array.prototype.slice.call(nodeList)// bind// attention: bind函数返回的是一个方法// studentA的对象绑定了sayName方法Person.sayName.bind(studentA) 总结this在JS中指向当前的上下文环境(context), 指向取决于包含它的函数的调用位置.实际使用中, 如何确定当前的上下文环境并不是一件容易的事情. 除了常见的点操作符(.)和中括号操作符([])等在代码中显示的绑定指向外，比较麻烦的是在方法中(function)声明的this, 在执行时才能确定this指向的隐式绑定.","categories":[{"name":"JS base","slug":"JS-base","permalink":"http://yoursite.com/categories/JS-base/"}],"tags":[{"name":"js this","slug":"js-this","permalink":"http://yoursite.com/tags/js-this/"}]},{"title":"前端面试题","slug":"interview-frontend","date":"2019-11-06T18:00:00.000Z","updated":"2019-11-06T18:00:00.000Z","comments":true,"path":"2019/11/06/interview-frontend/","link":"","permalink":"http://yoursite.com/2019/11/06/interview-frontend/","excerpt":"","text":"序言2019年9月中旬，决定从之前的公司离职。恰逢家里有些事情，我在十月上旬的末尾重新回到上海，并与中旬开始投递简历。感觉不同于以前，不需要怎么复习就能拿 Offer，我开始去面试的时候，大多时候面壁。在这期间，想想还是写点 blog, 记录下来这次特殊的求职经历，并以此共勉。 常见函数斐波那函数因兔子繁殖引入而又被称为”兔子数列”. 特征是从第三项开始, 每一项都是前两项之和。 12345678910111213141516171819// 用递归法实现斐波那契数列代码实现比较简洁，但在n比较大时会引起栈溢出，无法实现所需功能。function fib(n) &#123; if (n === 0) &#123; return 0 &#125; else if (n === 1) &#123; return 1 &#125; else &#123; return fib(n - 1) + fib(n - 2) &#125;&#125;// 尾调用function fib(n, ac1 = 1, ac2 = 1) &#123; if (n &lt;= 2) &#123; return ac2 &#125; return fib(n - 1, ac2, ac1 + ac2)&#125; 知名公司及笔试题分析笔试题其实对面试者来说，并不友好。实际开发时，开发者一般都有熟悉的ide，代码补全等工具进行辅助。当转移到了纸上，应聘者不仅需要牢记这些 api，留空白行的手感也完全不同。没有好好准备的话，不经浪费了大量的时间，而且还很容易被刷掉。因此，有换工作的同学，请务必提前3个月刷下题目，并练习下手写代码。 百度众测百度旗下的平台。稍微有点坑，对算法要求比较高。吐槽下，在JD里添加下重点考察算法如何。 1.1 实现排序 123456789101112131415161718192021222324252627282930313233343536// 在只检测是否为数组时, Array.isArray是一个更好的选项function isArray(arr) &#123; // return Object.prototype.toString.call(arr) === &#x27;[object Array]&#x27; return Array.isArray(arr)&#125;function sort(arr) &#123; if (!isArray(arr))&#123; return []; &#125; if (arr.length &lt; 2) &#123; return []; &#125; var length = arr.length; var temp = [arr[0]]; for (var i = 1; i &lt; length; i++) &#123; var tlen = temp.length; for(var j = 0; j &lt; tlen; j++) &#123; if(arr[i] &lt;= temp[0]) &#123; temp.unshift(arr[i]); break; &#125; if (arr[i] &gt;= temp[tlen - 1]) &#123; temp.push(arr[i]); break; &#125; if (arr[i] &gt;= temp[j] &amp;&amp; arr[i] &lt;= temp[j+1])&#123; temp.splice(j+1, 0, arr[i]); break; &#125; &#125; &#125; return temp;&#125;var arr = [5,4,3,2,1,2,3,6];sort(arr); // (8) [1, 2, 2, 3, 3, 4, 5, 6] 1.2 查找长字符中重复字符最多的字符 123456789101112131415161718192021222324252627282930function filter(string)&#123; var acc = []; var temp = string.split(&#x27;&#x27;).sort(); var length = string.length; var bcc = []; for (var i = 0; i &lt; length; i++) &#123; if (temp[i] !== bcc[0]) &#123; acc.push(bcc); bcc = []; bcc.push(temp[i]); &#125; else &#123; bcc.push(temp[i]); &#125; continue; &#125; // return acc; console.log(acc); // [Array(0), Array(1), Array(5), Array(2), Array(6), Array(2)] var accLen = acc.length; var maxLen = 0; var maxInd = 0; for (var j = 0; j &lt; accLen; j++) &#123; if (acc[j].length &gt; maxLen) &#123; maxLen = acc[j].length; maxInd = j; &#125; &#125; return acc[maxInd];&#125;var str = &#x27;asjfsjfjsifjilsjflsjf&#x27;;filter(str); // [&quot;j&quot;, &quot;j&quot;, &quot;j&quot;, &quot;j&quot;, &quot;j&quot;, &quot;j&quot;]","categories":[{"name":"interview","slug":"interview","permalink":"http://yoursite.com/categories/interview/"}],"tags":[{"name":"interview question","slug":"interview-question","permalink":"http://yoursite.com/tags/interview-question/"}]}],"categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"},{"name":"JS base","slug":"JS-base","permalink":"http://yoursite.com/categories/JS-base/"},{"name":"interview","slug":"interview","permalink":"http://yoursite.com/categories/interview/"}],"tags":[{"name":"hexo themes","slug":"hexo-themes","permalink":"http://yoursite.com/tags/hexo-themes/"},{"name":"js closure","slug":"js-closure","permalink":"http://yoursite.com/tags/js-closure/"},{"name":"js prototype","slug":"js-prototype","permalink":"http://yoursite.com/tags/js-prototype/"},{"name":"js this","slug":"js-this","permalink":"http://yoursite.com/tags/js-this/"},{"name":"interview question","slug":"interview-question","permalink":"http://yoursite.com/tags/interview-question/"}]}